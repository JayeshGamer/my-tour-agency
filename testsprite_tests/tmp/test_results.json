[
  {
    "projectId": "2aee7dae-d28b-438a-954c-ee4fc4b1e1fd",
    "testId": "de86b53a-3684-4413-9fa3-452bb3734be2",
    "userId": "74a864c8-3021-7018-200a-5ce7885b869e",
    "title": "TC001-userauthenticationwithbetterauth",
    "description": "Verify user authentication flows including OAuth (Google) and email/password methods, session management, and role-based access control to ensure secure login, registration, sign-out, and session retrieval.",
    "code": "import requests\nimport uuid\n\nBASE_URL = \"http://localhost:3000\"\nTIMEOUT = 30\n\n\ndef test_user_authentication_flows():\n    session = requests.Session()\n\n    # 1) Test user registration (email/password)\n    register_url = f\"{BASE_URL}/api/auth/sign-up\"\n    test_email = f\"testuser_{uuid.uuid4()}@example.com\"\n    register_payload = {\n        \"email\": test_email,\n        \"password\": \"TestPass123!\",\n        \"firstName\": \"Test\",\n        \"lastName\": \"User\"\n    }\n    try:\n        r = session.post(register_url, json=register_payload, timeout=TIMEOUT)\n        assert r.status_code == 201 or r.status_code == 200, f\"Registration failed: {r.text}\"\n\n        # 2) Test user sign in (email/password)\n        sign_in_url = f\"{BASE_URL}/api/auth/sign-in\"\n        sign_in_payload = {\n            \"email\": test_email,\n            \"password\": \"TestPass123!\"\n        }\n        r = session.post(sign_in_url, json=sign_in_payload, timeout=TIMEOUT)\n        assert r.status_code == 200, f\"Sign-in failed: {r.text}\"\n        # Normally token/session cookie set here; preserve session cookies\n        # We expect a cookie or token in Set-Cookie or response body\n        # Check presence of session cookie or token in response\n        # We'll check cookies saved in session\n        assert session.cookies, \"Session cookies not set after sign-in\"\n\n        # 3) Get current session information\n        session_url = f\"{BASE_URL}/api/auth/get-session\"\n        r = session.get(session_url, timeout=TIMEOUT)\n        assert r.status_code == 200, f\"Get session failed: {r.text}\"\n        session_data = r.json()\n        assert isinstance(session_data, dict), \"Session response is not a dict\"\n        # We expect at least user email and role in session data for RBAC\n        assert session_data.get(\"user\"), \"Session data missing 'user'\"\n        assert session_data[\"user\"].get(\"email\") == test_email, \"Session user email mismatch\"\n        # Check for role field presence\n        assert \"role\" in session_data[\"user\"], \"Role field missing in session user data\"\n\n        # 4) Check role-based access: try to access admin-only endpoint without admin rights\n        admin_tours_url = f\"{BASE_URL}/api/admin/tours\"\n        r = session.get(admin_tours_url, timeout=TIMEOUT)\n        # Expecting 403 Forbidden or 401 Unauthorized for non-admin user\n        assert r.status_code in (401, 403), f\"Non-admin user allowed admin access: {r.status_code}\"\n\n        # 5) Test sign out\n        sign_out_url = f\"{BASE_URL}/api/auth/sign-out\"\n        r = session.post(sign_out_url, timeout=TIMEOUT)\n        assert r.status_code == 200, f\"Sign out failed: {r.text}\"\n\n        # 6) After sign out, session should be invalid\n        r = session.get(session_url, timeout=TIMEOUT)\n        # Expect 401 Unauthorized or session empty/invalid\n        assert r.status_code == 401 or r.json().get(\"user\") is None, \"Session still valid after sign out\"\n\n        # 7) OAuth (Google) flow - We only simulate here as real OAuth needs redirect and front-end:\n        # Typically OAuth sign-in would happen via a front-end redirect.\n        # Check for existence of OAuth initiation endpoint or token endpoint\n        # Normally we test presence or 302 redirect, here we verify the endpoint exists:\n        oauth_url = f\"{BASE_URL}/api/auth/oauth/google\"\n        r = session.get(oauth_url, timeout=TIMEOUT)\n        # Accept either 404 Not Found (if OAuth endpoint isn't a GET) or 405 Method Not Allowed or redirect 3xx\n        assert r.status_code in (404, 405, 302, 301), \"Unexpected response for OAuth initiation endpoint\"\n\n    finally:\n        # Clean up: delete the test user via admin API if available (not specified, so skip)\n        pass\n\n\ntest_user_authentication_flows()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 80, in <module>\n  File \"<string>\", line 22, in test_user_authentication_flows\nAssertionError: Registration failed: \n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-09-19T16:21:34.601Z",
    "modified": "2025-09-19T16:22:44.969Z"
  },
  {
    "projectId": "2aee7dae-d28b-438a-954c-ee4fc4b1e1fd",
    "testId": "20c8c1c3-ea14-4c80-ab46-0e039c3c6a55",
    "userId": "74a864c8-3021-7018-200a-5ce7885b869e",
    "title": "TC002-tourcatalogmanagementwithsearchandfiltering",
    "description": "Test the tours API for accurate retrieval of tours with various filtering parameters such as search keyword, price range, difficulty, location, and featured flag, and verify admin-only tour creation functionality.",
    "code": "import requests\nimport json\n\nBASE_URL = \"http://localhost:3000\"\nTIMEOUT = 30\n\n# Replace these with actual valid credentials of an admin user in the test environment\nADMIN_EMAIL = \"admin@example.com\"\nADMIN_PASSWORD = \"AdminPassword123!\"\n\ndef test_tourcatalogmanagementwithsearchandfiltering():\n    session = requests.Session()\n    try:\n        # 1. Authenticate as admin to get token for admin-only endpoints\n        signin_resp = session.post(\n            f\"{BASE_URL}/api/auth/sign-in\",\n            json={\"email\": ADMIN_EMAIL, \"password\": ADMIN_PASSWORD},\n            timeout=TIMEOUT\n        )\n        assert signin_resp.status_code == 200, f\"Admin sign-in failed: {signin_resp.text}\"\n        # Session cookie or token assumed handled by session or returned in JSON (check session)\n        # We'll try to get session info to confirm authentication\n        session_resp = session.get(f\"{BASE_URL}/api/auth/get-session\", timeout=TIMEOUT)\n        assert session_resp.status_code == 200, f\"Failed to get session after admin sign-in: {session_resp.text}\"\n        session_data = session_resp.json()\n        assert session_data.get(\"user\") and session_data[\"user\"].get(\"role\") == \"admin\", \"User is not admin after sign in\"\n\n        # 2. Create a new tour as admin (for testing filters later)\n        new_tour_payload = {\n            \"name\": \"Test Tour Deluxe\",\n            \"title\": \"Deluxe Adventure Tour\",\n            \"description\": \"An exciting deluxe tour for testing filtering.\",\n            \"location\": \"Wonderland\",\n            \"duration\": 5,\n            \"pricePerPerson\": 350,\n            \"category\": \"Adventure\",\n            \"difficulty\": \"Hard\",\n            \"maxGroupSize\": 10,\n            \"images\": [\"https://example.com/image1.jpg\", \"https://example.com/image2.jpg\"],\n            \"startDates\": [\"2025-12-10T00:00:00Z\", \"2026-01-15T00:00:00Z\"],\n            \"included\": [\"Breakfast\", \"Guide\"],\n            \"notIncluded\": [\"Flights\"],\n            \"itinerary\": [\n                {\"day\": 1, \"activities\": [\"Arrival and welcome\"]},\n                {\"day\": 2, \"activities\": [\"Mountain climbing\"]}\n            ],\n            \"featured\": True\n        }\n        create_resp = session.post(\n            f\"{BASE_URL}/api/admin/tours\",\n            json=new_tour_payload,\n            timeout=TIMEOUT\n        )\n        assert create_resp.status_code == 201 or create_resp.status_code == 200, f\"Failed to create tour: {create_resp.text}\"\n        created_tour = create_resp.json()\n        assert created_tour.get(\"id\") or created_tour.get(\"_id\"), \"Created tour does not contain an ID\"\n        tour_id = created_tour.get(\"id\") or created_tour.get(\"_id\")\n\n        # 3. Define function to delete the tour after tests\n        def delete_tour(tid):\n            del_resp = session.delete(f\"{BASE_URL}/api/admin/tours/{tid}\", timeout=TIMEOUT)\n            # Some APIs might return 204 or 200 on delete\n            assert del_resp.status_code in (200, 204), f\"Failed to delete tour: {del_resp.text}\"\n\n        # 4. Test GET /api/tours with various filters\n        # Basic get all tours\n        get_all_resp = requests.get(f\"{BASE_URL}/api/tours\", timeout=TIMEOUT)\n        assert get_all_resp.status_code == 200, f\"Get all tours failed: {get_all_resp.text}\"\n        tours = get_all_resp.json()\n        assert isinstance(tours, list), \"Tours response is not a list\"\n\n        # Filter by search keyword (name/title)\n        params_search = {\"search\": \"Deluxe\"}\n        search_resp = requests.get(f\"{BASE_URL}/api/tours\", params=params_search, timeout=TIMEOUT)\n        assert search_resp.status_code == 200, f\"Search filter failed: {search_resp.text}\"\n        tours_search = search_resp.json()\n        assert any(\"Deluxe\" in (t.get(\"name\",\"\") + t.get(\"title\",\"\")) for t in tours_search), \\\n            \"Search filter did not return tours with the search keyword\"\n\n        # Filter by price range\n        params_price = {\"minPrice\": 300, \"maxPrice\": 400}\n        price_resp = requests.get(f\"{BASE_URL}/api/tours\", params=params_price, timeout=TIMEOUT)\n        assert price_resp.status_code == 200, f\"Price filter failed: {price_resp.text}\"\n        tours_price = price_resp.json()\n        for t in tours_price:\n            price = t.get(\"pricePerPerson\")\n            assert price is not None, \"Tour missing pricePerPerson in price range filter\"\n            assert 300 <= price <= 400, f\"Tour price {price} outside filter range\"\n\n        # Filter by difficulty\n        params_difficulty = {\"difficulty\": \"Hard\"}\n        diff_resp = requests.get(f\"{BASE_URL}/api/tours\", params=params_difficulty, timeout=TIMEOUT)\n        assert diff_resp.status_code == 200, f\"Difficulty filter failed: {diff_resp.text}\"\n        tours_diff = diff_resp.json()\n        for t in tours_diff:\n            assert t.get(\"difficulty\") == \"Hard\", \"Tour difficulty does not match filter\"\n\n        # Filter by location\n        params_location = {\"location\": \"Wonderland\"}\n        loc_resp = requests.get(f\"{BASE_URL}/api/tours\", params=params_location, timeout=TIMEOUT)\n        assert loc_resp.status_code == 200, f\"Location filter failed: {loc_resp.text}\"\n        tours_loc = loc_resp.json()\n        for t in tours_loc:\n            assert t.get(\"location\") == \"Wonderland\", \"Tour location does not match filter\"\n\n        # Filter by featured flag\n        params_featured = {\"featured\": \"true\"}\n        feat_resp = requests.get(f\"{BASE_URL}/api/tours\", params=params_featured, timeout=TIMEOUT)\n        assert feat_resp.status_code == 200, f\"Featured filter failed: {feat_resp.text}\"\n        tours_feat = feat_resp.json()\n        for t in tours_feat:\n            assert t.get(\"featured\") is True, \"Tour featured flag not true in filter results\"\n\n        # 5. Verify non-admin user cannot create tour\n        # Register normal user\n        user_email = \"testuser@example.com\"\n        user_password = \"UserPass123!\"\n        signup_resp = requests.post(\n            f\"{BASE_URL}/api/auth/sign-up\",\n            json={\"email\": user_email, \"password\": user_password, \"firstName\": \"Test\", \"lastName\": \"User\"},\n            timeout=TIMEOUT\n        )\n        assert signup_resp.status_code in (200,201), f\"User signup failed: {signup_resp.text}\"\n        # Sign-in user\n        user_session = requests.Session()\n        signin_user_resp = user_session.post(\n            f\"{BASE_URL}/api/auth/sign-in\",\n            json={\"email\": user_email, \"password\": user_password},\n            timeout=TIMEOUT\n        )\n        assert signin_user_resp.status_code == 200, f\"User sign-in failed: {signin_user_resp.text}\"\n\n        # Attempt to create tour with normal user session (non-admin)\n        create_tour_user_resp = user_session.post(\n            f\"{BASE_URL}/api/admin/tours\",\n            json=new_tour_payload,\n            timeout=TIMEOUT\n        )\n        assert create_tour_user_resp.status_code in (401,403), \"Non-admin user should not be able to create tour\"\n\n    finally:\n        # Cleanup - delete created tour if exists and if admin session available\n        try:\n            if 'tour_id' in locals():\n                # Delete tour via admin session\n                delete_resp = session.delete(f\"{BASE_URL}/api/admin/tours/{tour_id}\", timeout=TIMEOUT)\n                # Accept 204 No Content or 200 OK for delete\n                assert delete_resp.status_code in (200, 204), f\"Failed to delete tour in cleanup: {delete_resp.text}\"\n        except Exception:\n            pass\n        # Optionally, delete user created for test if API supports it (not specified)\n\ntest_tourcatalogmanagementwithsearchandfiltering()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 153, in <module>\n  File \"<string>\", line 20, in test_tourcatalogmanagementwithsearchandfiltering\nAssertionError: Admin sign-in failed: \n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-09-19T16:21:34.607Z",
    "modified": "2025-09-19T16:22:44.984Z"
  },
  {
    "projectId": "2aee7dae-d28b-438a-954c-ee4fc4b1e1fd",
    "testId": "8d9fcced-dad9-4f34-8c16-f95b9cb4f0a9",
    "userId": "74a864c8-3021-7018-200a-5ce7885b869e",
    "title": "TC003-bookingcreationandstatusupdateswithstripeintegration",
    "description": "Validate the booking creation process with required fields and Stripe payment intent integration, and test admin-only booking status updates including Pending, Confirmed, and Canceled states.",
    "code": "import requests\nimport datetime\n\nBASE_URL = \"http://localhost:3000\"\nTIMEOUT = 30\n\n# Credentials for test users (should exist in system or created beforehand)\nUSER_EMAIL = \"testuser@example.com\"\nUSER_PASSWORD = \"TestPass123!\"\nADMIN_EMAIL = \"adminuser@example.com\"\nADMIN_PASSWORD = \"AdminPass123!\"\n\ndef sign_in(email, password):\n    url = f\"{BASE_URL}/api/auth/sign-in\"\n    payload = {\"email\": email, \"password\": password}\n    try:\n        resp = requests.post(url, json=payload, timeout=TIMEOUT)\n        resp.raise_for_status()\n        data = resp.json()\n        # Assuming the token is in data['token'] or data['accessToken'], else session cookie is set\n        token = data.get(\"token\") or data.get(\"accessToken\")\n        if token:\n            return token\n        # If no token but session cookie is set, return session cookies for auth\n        return resp.cookies\n    except Exception as e:\n        raise Exception(f\"Sign-in failed for {email}: {e}\")\n\ndef create_tour(admin_auth):\n    url = f\"{BASE_URL}/api/admin/tours\"\n    # Create minimal required tour data\n    today_iso = datetime.datetime.utcnow().date().isoformat()\n    payload = {\n        \"name\": \"Test Tour for Booking\",\n        \"title\": \"Test Tour for Booking\",\n        \"description\": \"A tour created for testing booking flow.\",\n        \"location\": \"Testland\",\n        \"duration\": 3,\n        \"pricePerPerson\": 100,\n        \"category\": \"Adventure\",\n        \"difficulty\": \"Easy\",\n        \"maxGroupSize\": 10,\n        \"images\": [],\n        \"startDates\": [today_iso],\n        \"included\": [\"Guide\", \"Equipment\"],\n        \"notIncluded\": [\"Lunch\"],\n        \"itinerary\": [],\n        \"featured\": False\n    }\n    headers = {\"Authorization\": f\"Bearer {admin_auth}\"} if isinstance(admin_auth, str) else {}\n    try:\n        resp = requests.post(url, json=payload, headers=headers, cookies=None if headers else admin_auth, timeout=TIMEOUT)\n        resp.raise_for_status()\n        data = resp.json()\n        assert \"id\" in data, \"Tour creation response missing 'id'\"\n        return data[\"id\"]\n    except Exception as e:\n        raise Exception(f\"Failed to create tour: {e}\")\n\ndef create_payment_intent(user_auth, amount):\n    url = f\"{BASE_URL}/api/checkout/create-payment-intent\"\n    payload = {\"amount\": amount}\n    headers = {\"Authorization\": f\"Bearer {user_auth}\"} if isinstance(user_auth, str) else {}\n    try:\n        resp = requests.post(url, json=payload, headers=headers, cookies=None if headers else user_auth, timeout=TIMEOUT)\n        resp.raise_for_status()\n        data = resp.json()\n        assert \"id\" in data, \"Payment intent creation missing 'id'\"\n        return data[\"id\"]\n    except Exception as e:\n        raise Exception(f\"Failed to create payment intent: {e}\")\n\ndef create_booking(user_auth, tour_id, number_of_people, start_date, payment_intent_id):\n    url = f\"{BASE_URL}/api/bookings\"\n    payload = {\n        \"tourId\": tour_id,\n        \"numberOfPeople\": number_of_people,\n        \"startDate\": start_date,\n        \"paymentIntentId\": payment_intent_id\n    }\n    headers = {\"Authorization\": f\"Bearer {user_auth}\"} if isinstance(user_auth, str) else {}\n    try:\n        resp = requests.post(url, json=payload, headers=headers, cookies=None if headers else user_auth, timeout=TIMEOUT)\n        resp.raise_for_status()\n        data = resp.json()\n        assert \"id\" in data, \"Booking creation response missing 'id'\"\n        # Booking status should default to \"Pending\"\n        assert data.get(\"status\") == \"Pending\", f\"Unexpected booking status on creation: {data.get('status')}\"\n        return data[\"id\"], data\n    except Exception as e:\n        raise Exception(f\"Failed to create booking: {e}\")\n\ndef update_booking_status(admin_auth, booking_id, status, payment_intent_id=None):\n    url = f\"{BASE_URL}/api/admin/bookings/{booking_id}/status\"\n    payload = {\"bookingId\": booking_id, \"status\": status}\n    if payment_intent_id:\n        payload[\"paymentIntentId\"] = payment_intent_id\n    headers = {\"Authorization\": f\"Bearer {admin_auth}\"} if isinstance(admin_auth, str) else {}\n    try:\n        resp = requests.patch(url, json=payload, headers=headers, cookies=None if headers else admin_auth, timeout=TIMEOUT)\n        resp.raise_for_status()\n        data = resp.json()\n        assert data.get(\"status\") == status, f\"Booking status update failed, expected {status} but got {data.get('status')}\"\n        return data\n    except Exception as e:\n        raise Exception(f\"Failed to update booking status to {status}: {e}\")\n\ndef get_booking(user_auth, booking_id):\n    url = f\"{BASE_URL}/api/bookings\"\n    headers = {\"Authorization\": f\"Bearer {user_auth}\"} if isinstance(user_auth, str) else {}\n    try:\n        resp = requests.get(url, headers=headers, cookies=None if headers else user_auth, timeout=TIMEOUT)\n        resp.raise_for_status()\n        data = resp.json()\n        # Return booking with matching id or None\n        return next((b for b in data if b.get(\"id\") == booking_id), None)\n    except Exception as e:\n        raise Exception(f\"Failed to retrieve bookings: {e}\")\n\ndef delete_booking(admin_auth, booking_id):\n    # No explicit delete API described in PRD for bookings, skipping deletion step\n    # Usually, bookings are not deletable, so no attempt here.\n    pass\n\ndef test_booking_creation_and_status_updates_with_stripe_integration():\n    # Sign in user and admin\n    user_auth = sign_in(USER_EMAIL, USER_PASSWORD)\n    admin_auth = sign_in(ADMIN_EMAIL, ADMIN_PASSWORD)\n\n    # Create a tour as admin to book - will clean up the tour after test\n    tour_id = None\n    booking_id = None\n    try:\n        tour_id = create_tour(admin_auth)\n\n        # Calculate a booking start date (use one of the tour's start dates or tomorrow)\n        start_date = (datetime.datetime.utcnow() + datetime.timedelta(days=1)).date().isoformat() + \"T00:00:00Z\"\n\n        # Create Stripe payment intent for booking amount (pricePerPerson * numberOfPeople * 100 cents)\n        number_of_people = 2\n        amount = 100 * number_of_people * 100  # amount in cents\n\n        payment_intent_id = create_payment_intent(user_auth, amount)\n        assert payment_intent_id is not None and payment_intent_id != \"\", \"Invalid payment intent ID\"\n\n        # Create booking with tour, people count, start date and payment intent id\n        booking_id, booking_data = create_booking(user_auth, tour_id, number_of_people, start_date, payment_intent_id)\n        assert booking_id is not None and booking_id != \"\", \"Invalid booking ID\"\n\n        # Verify booking initially has status Pending\n        assert booking_data.get(\"status\") == \"Pending\", \"Booking initial status is not Pending\"\n\n        # Test admin status updates: Pending -> Confirmed\n        updated = update_booking_status(admin_auth, booking_id, \"Confirmed\", payment_intent_id=payment_intent_id)\n        assert updated.get(\"status\") == \"Confirmed\", \"Booking status not updated to Confirmed\"\n\n        # Test admin status updates: Confirmed -> Canceled\n        updated = update_booking_status(admin_auth, booking_id, \"Canceled\")\n        assert updated.get(\"status\") == \"Canceled\", \"Booking status not updated to Canceled\"\n\n        # Attempt invalid status update as user (should fail)\n        url = f\"{BASE_URL}/api/bookings\"\n        payload = {\n            \"bookingId\": booking_id,\n            \"status\": \"Confirmed\"\n        }\n        headers = {\"Authorization\": f\"Bearer {user_auth}\"} if isinstance(user_auth, str) else {}\n        try:\n            resp = requests.patch(url, json=payload, headers=headers, cookies=None if headers else user_auth, timeout=TIMEOUT)\n            # Expecting error for unauthorized status update\n            assert resp.status_code in (401,403), \"User should not be able to update booking status\"\n        except requests.exceptions.HTTPError as e:\n            assert e.response.status_code in (401,403), \"User not authorized to update booking status\"\n\n    finally:\n        # Cleanup: no explicit delete booking API per PRD, so skip booking deletion\n\n        # Delete created tour as admin\n        if tour_id:\n            url = f\"{BASE_URL}/api/admin/tours/{tour_id}\"\n            headers = {\"Authorization\": f\"Bearer {admin_auth}\"} if isinstance(admin_auth, str) else {}\n            try:\n                resp = requests.delete(url, headers=headers, cookies=None if headers else admin_auth, timeout=TIMEOUT)\n                if resp.status_code not in (200,204):\n                    pass  # Log warning or ignore; test cleanup attempt\n            except Exception:\n                pass\n\ntest_booking_creation_and_status_updates_with_stripe_integration()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"<string>\", line 18, in sign_in\n  File \"/var/task/requests/models.py\", line 1024, in raise_for_status\n    raise HTTPError(http_error_msg, response=self)\nrequests.exceptions.HTTPError: 404 Client Error: Not Found for url: http://localhost:3000/api/auth/sign-in\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 189, in <module>\n  File \"<string>\", line 127, in test_booking_creation_and_status_updates_with_stripe_integration\n  File \"<string>\", line 27, in sign_in\nException: Sign-in failed for testuser@example.com: 404 Client Error: Not Found for url: http://localhost:3000/api/auth/sign-in\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-09-19T16:21:34.611Z",
    "modified": "2025-09-19T16:22:40.521Z"
  },
  {
    "projectId": "2aee7dae-d28b-438a-954c-ee4fc4b1e1fd",
    "testId": "3c068eec-05d9-4b35-8388-28676e833ee7",
    "userId": "74a864c8-3021-7018-200a-5ce7885b869e",
    "title": "TC004-userreviewsubmissionandadminmoderation",
    "description": "Test user review submission with rating, comment, title, and booking association, retrieval with optional filtering by tour or user, and deletion by owner or admin with proper authorization and moderation controls.",
    "code": "import requests\nimport uuid\nimport datetime\n\nBASE_URL = \"http://localhost:3000\"\nTIMEOUT = 30\n\n# Test user review submission with rating, comment, title, and booking association,\n# retrieval with optional filtering by tour or user, and deletion by owner or admin with proper authorization and moderation controls.\n\ndef test_user_review_submission_and_admin_moderation():\n    # Helper functions\n    def sign_up_user(email, password, first_name, last_name):\n        resp = requests.post(\n            f\"{BASE_URL}/api/auth/sign-up\",\n            json={\n                \"email\": email,\n                \"password\": password,\n                \"firstName\": first_name,\n                \"lastName\": last_name,\n            },\n            timeout=TIMEOUT,\n        )\n        resp.raise_for_status()\n        return resp.json()\n\n    def sign_in_user(email, password):\n        resp = requests.post(\n            f\"{BASE_URL}/api/auth/sign-in\",\n            json={\"email\": email, \"password\": password},\n            timeout=TIMEOUT,\n        )\n        resp.raise_for_status()\n        # Assuming Bearer token in json.accessToken or in cookie/session; use json.token here\n        data = resp.json()\n        return data.get(\"accessToken\") or data.get(\"token\") or resp.cookies\n\n    def get_auth_headers(token):\n        if isinstance(token, dict):\n            # Cookies or session handling\n            return {\"Cookie\": \"; \".join([f\"{k}={v}\" for k,v in token.items()])}\n        return {\"Authorization\": f\"Bearer {token}\"}\n\n    def create_tour(admin_token):\n        tour_payload = {\n            \"name\": \"Test Tour \" + str(uuid.uuid4()),\n            \"title\": \"Amazing Test Tour\",\n            \"description\": \"A wonderful tour for testing review features.\",\n            \"location\": \"Testville\",\n            \"duration\": 3,\n            \"pricePerPerson\": 150,\n            \"category\": \"adventure\",\n            \"difficulty\": \"medium\",\n            \"maxGroupSize\": 10,\n            \"images\": [\"https://example.com/image.jpg\"],\n            \"startDates\": [datetime.datetime.utcnow().date().isoformat()],\n            \"included\": [\"Guide\", \"Transport\"],\n            \"notIncluded\": [\"Meals\"],\n            \"itinerary\": [{\"day\": 1, \"activity\": \"Arrival and briefing\"}],\n            \"featured\": False,\n        }\n        resp = requests.post(\n            f\"{BASE_URL}/api/admin/tours\",\n            json=tour_payload,\n            headers=get_auth_headers(admin_token),\n            timeout=TIMEOUT,\n        )\n        resp.raise_for_status()\n        return resp.json().get(\"id\") or resp.json().get(\"_id\") or resp.json().get(\"tourId\") or resp.json().get(\"id\")\n\n    def create_booking(user_token, tour_id):\n        now_iso = datetime.datetime.utcnow().isoformat() + \"Z\"\n        booking_payload = {\n            \"tourId\": tour_id,\n            \"numberOfPeople\": 1,\n            \"startDate\": now_iso,\n            \"paymentIntentId\": \"test_payment_intent_\" + str(uuid.uuid4()),\n        }\n        resp = requests.post(\n            f\"{BASE_URL}/api/bookings\",\n            json=booking_payload,\n            headers=get_auth_headers(user_token),\n            timeout=TIMEOUT,\n        )\n        resp.raise_for_status()\n        json_data = resp.json()\n        return json_data.get(\"id\") or json_data.get(\"bookingId\") or json_data.get(\"_id\")\n\n    def submit_review(user_token, tour_id, booking_id, rating=5, comment=\"Great tour!\", title=\"Loved it!\"):\n        review_payload = {\n            \"tourId\": tour_id,\n            \"rating\": rating,\n            \"comment\": comment,\n            \"title\": title,\n            \"bookingId\": booking_id,\n        }\n        resp = requests.post(\n            f\"{BASE_URL}/api/reviews\",\n            json=review_payload,\n            headers=get_auth_headers(user_token),\n            timeout=TIMEOUT,\n        )\n        resp.raise_for_status()\n        return resp.json().get(\"id\") or resp.json().get(\"reviewId\") or resp.json().get(\"_id\")\n\n    def get_reviews(user_token=None, tour_id=None, user_id=None):\n        params = {}\n        if tour_id:\n            params[\"tourId\"] = tour_id\n        if user_id:\n            params[\"userId\"] = user_id\n        headers = get_auth_headers(user_token) if user_token else {}\n        resp = requests.get(f\"{BASE_URL}/api/reviews\", headers=headers, params=params, timeout=TIMEOUT)\n        resp.raise_for_status()\n        return resp.json()\n\n    def delete_review(user_token, review_id):\n        # According to schema: DELETE on /api/reviews with body containing reviewId\n        # Use user token (owner or admin)\n        payload = {\"reviewId\": review_id}\n        resp = requests.delete(\n            f\"{BASE_URL}/api/reviews\",\n            json=payload,\n            headers=get_auth_headers(user_token),\n            timeout=TIMEOUT,\n        )\n        resp.raise_for_status()\n        return resp\n\n    def admin_delete_review(admin_token, review_id):\n        # Admin can delete review via /api/admin/reviews/{id} DELETE\n        resp = requests.delete(\n            f\"{BASE_URL}/api/admin/reviews/{review_id}\",\n            headers=get_auth_headers(admin_token),\n            timeout=TIMEOUT,\n        )\n        resp.raise_for_status()\n        return resp\n\n    def get_session(token):\n        headers = get_auth_headers(token)\n        resp = requests.get(f\"{BASE_URL}/api/auth/get-session\", headers=headers, timeout=TIMEOUT)\n        resp.raise_for_status()\n        return resp.json()\n\n    # Create admin user and normal user for testing\n    admin_email = \"admin_\" + str(uuid.uuid4()) + \"@test.com\"\n    admin_pass = \"AdminPass123!\"\n    user_email = \"user_\" + str(uuid.uuid4()) + \"@test.com\"\n    user_pass = \"UserPass123!\"\n\n    # We assume an admin user already exists, or we create one - here we simulate sign-up and then promote to admin (not implemented),\n    # so we login with assumed existing admin credentials. If unavailable, skip admin functionality.\n\n    # For robustness, let's try to sign-up and sign-in both admin and user, but admin operations may fail if not really admin.\n\n    # Sign up and sign in user\n    sign_up_user(user_email, user_pass, \"John\", \"Doe\")\n    user_token = sign_in_user(user_email, user_pass)\n    assert user_token, \"User authentication failed\"\n\n    # Sign up and sign in admin\n    try:\n        sign_up_user(admin_email, admin_pass, \"Admin\", \"User\")\n    except requests.HTTPError:\n        # If admin sign-up not allowed, skip sign-up\n        pass\n    admin_token = sign_in_user(admin_email, admin_pass)\n    assert admin_token, \"Admin authentication failed\"\n\n    # Get user profile to retrieve userId\n    user_session = get_session(user_token)\n    user_id = user_session.get(\"user\", {}).get(\"id\") or user_session.get(\"user\", {}).get(\"_id\")\n    assert user_id, \"Failed to get user ID from session\"\n\n    # Create a new tour by admin (needed for booking and review)\n    tour_id = None\n    booking_id = None\n    review_id = None\n\n    try:\n        tour_id = create_tour(admin_token)\n        assert tour_id, \"Failed to create tour\"\n\n        # Create a booking for the user associated with the tour\n        booking_id = create_booking(user_token, tour_id)\n        assert booking_id, \"Failed to create booking\"\n\n        # Submit a review\n        review_id = submit_review(user_token, tour_id, booking_id)\n        assert review_id, \"Failed to submit review\"\n\n        # Retrieve reviews filtered by tourId\n        reviews_by_tour = get_reviews(tour_id=tour_id)\n        assert any(r.get(\"id\") == review_id or r.get(\"_id\") == review_id for r in reviews_by_tour), \\\n            \"Review not found when filtered by tourId\"\n\n        # Retrieve reviews filtered by userId\n        reviews_by_user = get_reviews(user_id=user_id)\n        assert any(r.get(\"id\") == review_id or r.get(\"_id\") == review_id for r in reviews_by_user), \\\n            \"Review not found when filtered by userId\"\n\n        # User deletes own review\n        del_resp = delete_review(user_token, review_id)\n        assert del_resp.status_code == 200\n\n        # Verify review is deleted (should not appear in reviews)\n        reviews_after_delete = get_reviews(tour_id=tour_id)\n        assert all(r.get(\"id\") != review_id and r.get(\"_id\") != review_id for r in reviews_after_delete), \\\n            \"Review still present after user deletion\"\n\n        # Re-submit review to test admin deletion\n        review_id = submit_review(user_token, tour_id, booking_id)\n        assert review_id, \"Failed to re-submit review for admin deletion test\"\n\n        # Admin deletes review\n        del_admin_resp = admin_delete_review(admin_token, review_id)\n        assert del_admin_resp.status_code == 200\n\n        # Verify review deleted by admin\n        reviews_after_admin_delete = get_reviews(tour_id=tour_id)\n        assert all(r.get(\"id\") != review_id and r.get(\"_id\") != review_id for r in reviews_after_admin_delete), \\\n            \"Review still present after admin deletion\"\n\n    finally:\n        # Cleanup: delete booking, tour if applicable (no direct delete from bookings mentioned, assume only admin tour delete)\n        if review_id:\n            try:\n                delete_review(user_token, review_id)\n            except Exception:\n                pass\n        if booking_id:\n            # No delete endpoint for booking in PRD, so skip unless admin can remove bookings\n            pass\n        if tour_id:\n            try:\n                resp = requests.delete(\n                    f\"{BASE_URL}/api/admin/tours/{tour_id}\",\n                    headers=get_auth_headers(admin_token),\n                    timeout=TIMEOUT,\n                )\n                if resp.status_code not in (200, 204):\n                    pass  # ignore errors in cleanup\n            except Exception:\n                pass\n\ntest_user_review_submission_and_admin_moderation()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 247, in <module>\n  File \"<string>\", line 158, in test_user_review_submission_and_admin_moderation\n  File \"<string>\", line 24, in sign_up_user\n  File \"/var/task/requests/models.py\", line 1024, in raise_for_status\n    raise HTTPError(http_error_msg, response=self)\nrequests.exceptions.HTTPError: 404 Client Error: Not Found for url: http://localhost:3000/api/auth/sign-up\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-09-19T16:21:34.616Z",
    "modified": "2025-09-19T16:22:36.980Z"
  },
  {
    "projectId": "2aee7dae-d28b-438a-954c-ee4fc4b1e1fd",
    "testId": "6c1f748f-0f9d-48b7-b855-56423d4ec8ae",
    "userId": "74a864c8-3021-7018-200a-5ce7885b869e",
    "title": "TC005-stripepaymentintentcreationandcouponapplication",
    "description": "Verify the creation of Stripe payment intents with minimum amount validation and the application of discount coupons with correct code and amount handling.",
    "code": "import requests\nimport uuid\n\nBASE_URL = \"http://localhost:3000\"\nTIMEOUT = 30\n\n# Placeholder for authentication token - needs to be replaced with a valid token for the tests to pass\nAUTH_TOKEN = \"Bearer your_valid_token_here\"\n\ndef test_stripe_payment_intent_creation_and_coupon_application():\n    # Test minimum amount validation for payment intent creation and coupon application handling\n\n    headers = {\n        \"Content-Type\": \"application/json\",\n        \"Authorization\": AUTH_TOKEN\n    }\n\n    # 1. Test: Create payment intent with amount less than minimum (50) - expect error\n    invalid_amount_payload = {\"amount\": 40}\n    try:\n        resp = requests.post(\n            f\"{BASE_URL}/api/checkout/create-payment-intent\",\n            json=invalid_amount_payload,\n            headers=headers,\n            timeout=TIMEOUT,\n        )\n        if resp.status_code in (400, 422):\n            pass\n        elif resp.status_code == 200:\n            data = resp.json()\n            assert \"id\" not in data, \"Payment intent should not be created with amount below minimum\"\n        else:\n            assert False, f\"Unexpected status code for invalid amount: {resp.status_code}\"\n    except requests.RequestException as e:\n        assert False, f\"Request failed during invalid amount test: {e}\"\n\n    # 2. Test: Create payment intent with valid minimum amount\n    valid_amount_payload = {\"amount\": 100}\n    payment_intent_id = None\n    try:\n        resp = requests.post(\n            f\"{BASE_URL}/api/checkout/create-payment-intent\",\n            json=valid_amount_payload,\n            headers=headers,\n            timeout=TIMEOUT,\n        )\n        assert resp.status_code == 200, f\"Unexpected status code: {resp.status_code}\"\n        data = resp.json()\n        assert \"id\" in data, \"Payment intent ID missing in response\"\n        payment_intent_id = data.get(\"id\")\n        assert isinstance(payment_intent_id, str) and payment_intent_id, \"Invalid payment intent ID\"\n    except requests.RequestException as e:\n        assert False, f\"Request failed during valid amount payment intent creation: {e}\"\n\n    # 3. Test: Apply coupon with valid code and amount\n    coupon_code = f\"TESTCOUPON-{uuid.uuid4().hex[:8].upper()}\"\n    coupon_amount = 10\n\n    apply_coupon_payload = {\n        \"code\": coupon_code,\n        \"amount\": coupon_amount\n    }\n    try:\n        resp = requests.post(\n            f\"{BASE_URL}/api/checkout/apply-coupon\",\n            json=apply_coupon_payload,\n            headers=headers,\n            timeout=TIMEOUT,\n        )\n        if resp.status_code == 200:\n            data = resp.json()\n            assert \"success\" in data or \"discount\" in data or \"message\" in data, (\n                \"Response missing expected coupon application details\"\n            )\n        else:\n            assert resp.status_code == 400 or resp.status_code == 404, (\n                f\"Unexpected status code on apply coupon: {resp.status_code}\"\n            )\n    except requests.RequestException as e:\n        assert False, f\"Request failed during coupon application test: {e}\"\n\n    # 4. Test: Apply coupon with zero or negative amount - expect error or handled gracefully\n    invalid_coupon_payload = {\n        \"code\": \"VALIDCODE\",\n        \"amount\": 0\n    }\n    try:\n        resp = requests.post(\n            f\"{BASE_URL}/api/checkout/apply-coupon\",\n            json=invalid_coupon_payload,\n            headers=headers,\n            timeout=TIMEOUT,\n        )\n        assert resp.status_code == 400 or resp.status_code == 422, (\n            \"Expected client error for coupon application with zero or negative amount\"\n        )\n    except requests.RequestException as e:\n        assert False, f\"Request failed during invalid coupon amount test: {e}\"\n\n\ntest_stripe_payment_intent_creation_and_coupon_application()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 101, in <module>\n  File \"<string>\", line 33, in test_stripe_payment_intent_creation_and_coupon_application\nAssertionError: Unexpected status code for invalid amount: 401\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-09-19T16:21:34.621Z",
    "modified": "2025-09-19T16:23:17.225Z"
  },
  {
    "projectId": "2aee7dae-d28b-438a-954c-ee4fc4b1e1fd",
    "testId": "4f4a6323-ffd9-4fc2-854e-121a75528589",
    "userId": "74a864c8-3021-7018-200a-5ce7885b869e",
    "title": "TC006-admindashboardmanagementfeatures",
    "description": "Test admin dashboard APIs for managing tours, bookings, users, reviews, coupons, notifications, and system logs with role-based access control and correct data handling.",
    "code": "import requests\nimport uuid\nimport time\n\nBASE_URL = \"http://localhost:3000\"\nTIMEOUT = 30\n\nADMIN_EMAIL = \"admin@example.com\"\nADMIN_PASSWORD = \"AdminPass123!\"\n\nHEADERS_JSON = {\"Content-Type\": \"application/json\"}\n\ndef admin_sign_in():\n    session = requests.Session()\n    url = f\"{BASE_URL}/api/auth/sign-in\"\n    data = {\"email\": ADMIN_EMAIL, \"password\": ADMIN_PASSWORD}\n    resp = session.post(url, json=data, headers=HEADERS_JSON, timeout=TIMEOUT)\n    resp.raise_for_status()\n    # According to PRD, sign-in uses session management (cookies), no token field.\n    # Ensure session cookies exist\n    assert session.cookies, \"No session cookies set after sign-in\"\n    return session\n\ndef create_tour(session):\n    url = f\"{BASE_URL}/api/admin/tours\"\n    tour_payload = {\n        \"name\": f\"Test Tour {uuid.uuid4()}\",\n        \"title\": \"Admin Test Tour Title\",\n        \"description\": \"A test tour created during admin dashboard API testing.\",\n        \"location\": \"Testland\",\n        \"duration\": 5,\n        \"pricePerPerson\": 150,\n        \"category\": \"Adventure\",\n        \"difficulty\": \"Medium\",\n        \"maxGroupSize\": 10,\n        \"images\": [\"https://example.com/image1.jpg\"],\n        \"startDates\": [(time.strftime(\"%Y-%m-%dT%H:%M:%S\"))],\n        \"included\": [\"Guide\", \"Lunch\"],\n        \"notIncluded\": [\"Flights\"],\n        \"itinerary\": [{\"day\": 1, \"activities\": [\"Arrival\", \"City tour\"]}],\n        \"featured\": True\n    }\n    resp = session.post(url, json=tour_payload, timeout=TIMEOUT)\n    resp.raise_for_status()\n    created_tour = resp.json()\n    assert \"id\" in created_tour, \"Created tour ID not found in response\"\n    return created_tour\n\ndef delete_tour(tour_id, session):\n    # No delete endpoint specified in PRD, so no action\n    pass\n\ndef create_coupon(session):\n    url = f\"{BASE_URL}/api/admin/coupons\"\n    coupon_payload = {\n        \"code\": f\"TESTCOUPON{uuid.uuid4().hex[:6].upper()}\"\n    }\n    resp = session.post(url, json=coupon_payload, timeout=TIMEOUT)\n    if resp.status_code != 201:\n        return None\n    created_coupon = resp.json()\n    assert \"id\" in created_coupon or \"code\" in created_coupon, \"Coupon creation failed or missing id/code\"\n    return created_coupon\n\ndef get_users(session):\n    url = f\"{BASE_URL}/api/admin/users\"\n    resp = session.get(url, timeout=TIMEOUT)\n    resp.raise_for_status()\n    users = resp.json()\n    assert isinstance(users, list), \"Users response is not a list\"\n    return users\n\ndef get_bookings(session):\n    url = f\"{BASE_URL}/api/admin/bookings\"\n    resp = session.get(url, timeout=TIMEOUT)\n    resp.raise_for_status()\n    bookings = resp.json()\n    assert isinstance(bookings, list), \"Bookings response is not a list\"\n    return bookings\n\ndef update_booking_status(booking_id, new_status, session):\n    url = f\"{BASE_URL}/api/admin/bookings/{booking_id}/status\"\n    payload = {\"status\": new_status}\n    resp = session.patch(url, json=payload, timeout=TIMEOUT)\n    resp.raise_for_status()\n    updated = resp.json()\n    assert updated.get(\"status\") == new_status, f\"Booking status not updated to {new_status}\"\n    return updated\n\ndef get_reviews(session):\n    url = f\"{BASE_URL}/api/admin/reviews\"\n    resp = session.get(url, timeout=TIMEOUT)\n    if resp.status_code == 404:\n        return []\n    resp.raise_for_status()\n    reviews = resp.json()\n    assert isinstance(reviews, list), \"Reviews response is not a list\"\n    return reviews\n\ndef delete_review(review_id, session):\n    url = f\"{BASE_URL}/api/admin/reviews/{review_id}\"\n    resp = session.delete(url, timeout=TIMEOUT)\n    resp.raise_for_status()\n\ndef get_coupons(session):\n    url = f\"{BASE_URL}/api/admin/coupons\"\n    resp = session.get(url, timeout=TIMEOUT)\n    resp.raise_for_status()\n    coupons = resp.json()\n    assert isinstance(coupons, list), \"Coupons response is not a list\"\n    return coupons\n\ndef get_notifications(session):\n    url = f\"{BASE_URL}/api/admin/notifications\"\n    resp = session.get(url, timeout=TIMEOUT)\n    resp.raise_for_status()\n    notifs = resp.json()\n    assert isinstance(notifs, list), \"Notifications response is not a list\"\n    return notifs\n\ndef get_system_logs(session):\n    url = f\"{BASE_URL}/api/admin/logs\"\n    resp = session.get(url, timeout=TIMEOUT)\n    resp.raise_for_status()\n    logs = resp.json()\n    assert isinstance(logs, list), \"System logs response is not a list\"\n    return logs\n\n\ndef test_admin_dashboard_management_features():\n    # Authenticate as admin\n    session = admin_sign_in()\n\n    created_tour = None\n    try:\n        # Tours: Create a new tour (admin only)\n        created_tour = create_tour(session)\n        tour_id = created_tour.get(\"id\")\n\n        # Tours: Get all tours (admin only)\n        tours_resp = session.get(f\"{BASE_URL}/api/admin/tours\", timeout=TIMEOUT)\n        tours_resp.raise_for_status()\n        tours = tours_resp.json()\n        assert any(t.get(\"id\") == tour_id for t in tours), \"Created tour not found in tours list\"\n\n        # Users: Get all users (admin only)\n        users = get_users(session)\n        assert users, \"No users returned\"\n\n        # Bookings: Get all bookings (admin only)\n        bookings = get_bookings(session)\n        if bookings:\n            booking = bookings[0]\n            booking_id = booking.get(\"id\") or booking.get(\"bookingId\")\n            if booking_id:\n                current_status = booking.get(\"status\", \"Pending\")\n                new_status = \"Confirmed\" if current_status != \"Confirmed\" else \"Canceled\"\n                updated_booking = update_booking_status(booking_id, new_status, session)\n                assert updated_booking.get(\"status\") == new_status\n\n        # Reviews: Get reviews (admin)\n        reviews = get_reviews(session)\n        if reviews:\n            review = reviews[0]\n            review_id = review.get(\"id\") or review.get(\"reviewId\")\n            if review_id:\n                delete_review(review_id, session)\n                reviews_after_delete = get_reviews(session)\n                assert all(r.get(\"id\") != review_id for r in reviews_after_delete)\n\n        # Coupons: Create and list coupons\n        coupon_created = None\n        try:\n            coupon_created = create_coupon(session)\n        except Exception:\n            coupon_created = None\n\n        coupons = get_coupons(session)\n        if coupon_created:\n            assert any(c.get(\"code\") == coupon_created.get(\"code\") for c in coupons)\n\n        # Notifications: Get admin notifications\n        notifications = get_notifications(session)\n\n        # System Logs: Get system logs (admin only)\n        logs = get_system_logs(session)\n\n        assert isinstance(notifications, list), \"Notifications not a list\"\n        assert isinstance(logs, list), \"System logs not a list\"\n    finally:\n        if created_tour:\n            pass\n\n\ntest_admin_dashboard_management_features()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 195, in <module>\n  File \"<string>\", line 132, in test_admin_dashboard_management_features\n  File \"<string>\", line 18, in admin_sign_in\n  File \"/var/task/requests/models.py\", line 1024, in raise_for_status\n    raise HTTPError(http_error_msg, response=self)\nrequests.exceptions.HTTPError: 404 Client Error: Not Found for url: http://localhost:3000/api/auth/sign-in\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-09-19T16:21:34.626Z",
    "modified": "2025-09-19T16:23:10.012Z"
  },
  {
    "projectId": "2aee7dae-d28b-438a-954c-ee4fc4b1e1fd",
    "testId": "8f005f2a-f866-4b1b-8320-e98404d805c1",
    "userId": "74a864c8-3021-7018-200a-5ce7885b869e",
    "title": "TC007-userprofilemanagementandpasswordupdates",
    "description": "Validate user profile retrieval and updates including personal information and secure password changes with proper authentication.",
    "code": "import requests\nimport uuid\n\nBASE_URL = \"http://localhost:3000\"\nTIMEOUT = 30\n\n# Test user credentials for sign up and sign in\nTEST_USER_EMAIL = f\"testuser_{uuid.uuid4().hex[:8]}@example.com\"\nTEST_USER_PASSWORD = \"TestPass123!\"\nTEST_USER_FIRST_NAME = \"Test\"\nTEST_USER_LAST_NAME = \"User\"\n\n\ndef test_userprofilemanagementandpasswordupdates():\n    session = requests.Session()\n\n    def sign_up():\n        url = f\"{BASE_URL}/api/auth/sign-up\"\n        payload = {\n            \"email\": TEST_USER_EMAIL,\n            \"password\": TEST_USER_PASSWORD,\n            \"firstName\": TEST_USER_FIRST_NAME,\n            \"lastName\": TEST_USER_LAST_NAME\n        }\n        resp = session.post(url, json=payload, timeout=TIMEOUT)\n        resp.raise_for_status()\n        assert resp.status_code == 200 or resp.status_code == 201\n\n    def sign_in():\n        url = f\"{BASE_URL}/api/auth/sign-in\"\n        payload = {\n            \"email\": TEST_USER_EMAIL,\n            \"password\": TEST_USER_PASSWORD\n        }\n        resp = session.post(url, json=payload, timeout=TIMEOUT)\n        resp.raise_for_status()\n        assert resp.status_code == 200\n        # Expect a cookie/session token in response\n        assert resp.cookies or 'authorization' in resp.headers or 'Authorization' in resp.headers\n\n    def get_auth_headers():\n        # This assumes session cookies are managed by requests.Session automatically.\n        return {}\n\n    def get_profile():\n        url = f\"{BASE_URL}/api/profile\"\n        resp = session.get(url, headers=get_auth_headers(), timeout=TIMEOUT)\n        resp.raise_for_status()\n        assert resp.status_code == 200\n        profile_data = resp.json()\n        assert isinstance(profile_data, dict)\n        assert profile_data.get(\"email\") == TEST_USER_EMAIL\n        return profile_data\n\n    def update_profile(new_first_name, new_last_name):\n        url = f\"{BASE_URL}/api/profile\"\n        payload = {\n            \"firstName\": new_first_name,\n            \"lastName\": new_last_name\n        }\n        resp = session.patch(url, json=payload, headers=get_auth_headers(), timeout=TIMEOUT)\n        resp.raise_for_status()\n        assert resp.status_code == 200\n        updated_data = resp.json()\n        assert updated_data.get(\"firstName\") == new_first_name\n        assert updated_data.get(\"lastName\") == new_last_name\n        return updated_data\n\n    def update_password(old_password, new_password):\n        url = f\"{BASE_URL}/api/profile/password\"\n        payload = {\n            \"oldPassword\": old_password,\n            \"newPassword\": new_password\n        }\n        resp = session.patch(url, json=payload, headers=get_auth_headers(), timeout=TIMEOUT)\n        resp.raise_for_status()\n        assert resp.status_code == 200\n\n    def sign_out():\n        url = f\"{BASE_URL}/api/auth/sign-out\"\n        resp = session.post(url, headers=get_auth_headers(), timeout=TIMEOUT)\n        resp.raise_for_status()\n        assert resp.status_code == 200\n\n    # Start of the test\n    sign_up()\n    sign_in()\n\n    # Get current profile and confirm info\n    profile = get_profile()\n    assert profile.get(\"firstName\") == TEST_USER_FIRST_NAME\n    assert profile.get(\"lastName\") == TEST_USER_LAST_NAME\n    assert profile.get(\"email\") == TEST_USER_EMAIL\n\n    # Update personal info\n    new_first_name = \"UpdatedFirst\"\n    new_last_name = \"UpdatedLast\"\n    updated_profile = update_profile(new_first_name, new_last_name)\n    assert updated_profile.get(\"firstName\") == new_first_name\n    assert updated_profile.get(\"lastName\") == new_last_name\n\n    # Verify changes persist\n    profile_after_update = get_profile()\n    assert profile_after_update.get(\"firstName\") == new_first_name\n    assert profile_after_update.get(\"lastName\") == new_last_name\n\n    # Update password securely\n    new_password = \"NewPass456!\"\n    update_password(TEST_USER_PASSWORD, new_password)\n\n    # Sign out and sign in with new password to verify change\n    sign_out()\n    # Clear session cookies to simulate fresh login\n    session.cookies.clear()\n    # Sign in with old password should fail\n    url_sign_in = f\"{BASE_URL}/api/auth/sign-in\"\n    resp_old_pass = session.post(url_sign_in, json={\"email\": TEST_USER_EMAIL, \"password\": TEST_USER_PASSWORD}, timeout=TIMEOUT)\n    assert resp_old_pass.status_code == 401 or resp_old_pass.status_code == 400\n\n    # Sign in with new password should succeed\n    resp_new_pass = session.post(url_sign_in, json={\"email\": TEST_USER_EMAIL, \"password\": new_password}, timeout=TIMEOUT)\n    resp_new_pass.raise_for_status()\n    assert resp_new_pass.status_code == 200\n\n    # Clean up: sign out\n    sign_out()\n\n\ntest_userprofilemanagementandpasswordupdates()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 129, in <module>\n  File \"<string>\", line 86, in test_userprofilemanagementandpasswordupdates\n  File \"<string>\", line 26, in sign_up\n  File \"/var/task/requests/models.py\", line 1024, in raise_for_status\n    raise HTTPError(http_error_msg, response=self)\nrequests.exceptions.HTTPError: 404 Client Error: Not Found for url: http://localhost:3000/api/auth/sign-up\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-09-19T16:21:34.631Z",
    "modified": "2025-09-19T16:22:44.980Z"
  },
  {
    "projectId": "2aee7dae-d28b-438a-954c-ee4fc4b1e1fd",
    "testId": "3ffeeba6-2d8f-4185-bdaa-c3083c829216",
    "userId": "74a864c8-3021-7018-200a-5ce7885b869e",
    "title": "TC008-userwishlistfunctionality",
    "description": "Test wishlist API for adding, removing, and retrieving favorite tours for authenticated users ensuring data consistency and access control.",
    "code": "import requests\nimport uuid\n\nBASE_URL = \"http://localhost:3000\"\nTIMEOUT = 30\n\n# Test user credentials\nTEST_USER_EMAIL = f\"testuser_{uuid.uuid4().hex[:8]}@example.com\"\nTEST_USER_PASSWORD = \"TestPassword123!\"\nTEST_USER_FIRSTNAME = \"Test\"\nTEST_USER_LASTNAME = \"User\"\n\n# Tour data for creating a tour to add to wishlist\nTEST_TOUR_DATA = {\n    \"name\": \"Test Tour \" + uuid.uuid4().hex[:6],\n    \"title\": \"Test Tour Title\",\n    \"description\": \"Test description for wishlist functionality\",\n    \"location\": \"Test Location\",\n    \"duration\": 3,\n    \"pricePerPerson\": 123,\n    \"category\": \"Adventure\",\n    \"difficulty\": \"Moderate\",\n    \"maxGroupSize\": 10,\n    \"images\": [\"https://example.com/image1.jpg\"],\n    \"startDates\": [\"2025-12-01\", \"2025-12-15\"],\n    \"included\": [\"Guide\", \"Meals\"],\n    \"notIncluded\": [\"Flights\"],\n    \"itinerary\": [{\"day\": 1, \"activities\": [\"Hiking\", \"Camping\"]}],\n    \"featured\": False\n}\n\n\ndef test_user_wishlist_functionality():\n    session = requests.Session()\n    headers = {'Content-Type': 'application/json'}\n    try:\n        # 1. Register a new user\n        sign_up_resp = session.post(\n            f\"{BASE_URL}/api/auth/sign-up\",\n            json={\n                \"email\": TEST_USER_EMAIL,\n                \"password\": TEST_USER_PASSWORD,\n                \"firstName\": TEST_USER_FIRSTNAME,\n                \"lastName\": TEST_USER_LASTNAME,\n            },\n            headers=headers,\n            timeout=TIMEOUT,\n        )\n        assert sign_up_resp.status_code in (200, 201), f\"Sign-up failed: {sign_up_resp.status_code} {sign_up_resp.text}\"\n\n        # 2. Sign in with the created user to get session cookie or tokens\n        sign_in_resp = session.post(\n            f\"{BASE_URL}/api/auth/sign-in\",\n            json={\"email\": TEST_USER_EMAIL, \"password\": TEST_USER_PASSWORD},\n            headers=headers,\n            timeout=TIMEOUT,\n        )\n        assert sign_in_resp.status_code == 200, f\"Sign-in failed: {sign_in_resp.status_code} {sign_in_resp.text}\"\n\n        # 3. Verify authenticated session by getting session info\n        session_resp = session.get(f\"{BASE_URL}/api/auth/get-session\", timeout=TIMEOUT)\n        assert session_resp.status_code == 200, f\"Get session failed: {session_resp.status_code} {session_resp.text}\"\n        session_data = session_resp.json()\n        assert session_data.get(\"user\"), \"Session data missing user info\"\n\n        # 4. Create a new tour via admin endpoint since wishlist needs a tour to add\n        # For this test, we try without auth, if 401 then fail\n        create_tour_resp = session.post(\n            f\"{BASE_URL}/api/admin/tours\",\n            json=TEST_TOUR_DATA,\n            headers=headers,\n            timeout=TIMEOUT,\n        )\n\n        if create_tour_resp.status_code == 401:\n            raise AssertionError(\"Cannot create tour without admin access; test requires a valid tour ID\")\n\n        assert create_tour_resp.status_code in (200, 201), f\"Create tour failed: {create_tour_resp.status_code} {create_tour_resp.text}\"\n\n        tour = create_tour_resp.json()\n        tour_id = tour.get(\"id\")\n        assert tour_id, \"Created tour missing id\"\n\n        try:\n            # 5. Add the tour to user's wishlist (POST /api/wishlist with tourId)\n            add_wishlist_resp = session.post(\n                f\"{BASE_URL}/api/wishlist\",\n                json={\"tourId\": tour_id},\n                headers=headers,\n                timeout=TIMEOUT,\n            )\n            assert add_wishlist_resp.status_code == 200, f\"Add to wishlist failed: {add_wishlist_resp.text}\"\n            add_result = add_wishlist_resp.json()\n            assert add_result.get(\"success\") or add_result.get(\"message\"), \"Unexpected add wishlist response\"\n\n            # 6. Retrieve the wishlist for the user (GET /api/wishlist)\n            get_wishlist_resp = session.get(f\"{BASE_URL}/api/wishlist\", timeout=TIMEOUT)\n            assert get_wishlist_resp.status_code == 200, f\"Get wishlist failed: {get_wishlist_resp.text}\"\n            wishlist = get_wishlist_resp.json()\n            assert any(item.get(\"tourId\") == tour_id or item.get(\"id\") == tour_id for item in wishlist), \\\n                \"Tour not found in wishlist after adding\"\n\n            # 7. Remove the tour from wishlist (DELETE /api/wishlist with tourId)\n            remove_wishlist_resp = session.delete(\n                f\"{BASE_URL}/api/wishlist\",\n                json={\"tourId\": tour_id},\n                headers=headers,\n                timeout=TIMEOUT,\n            )\n            assert remove_wishlist_resp.status_code == 200, f\"Remove from wishlist failed: {remove_wishlist_resp.text}\"\n            remove_result = remove_wishlist_resp.json()\n            assert remove_result.get(\"success\") or remove_result.get(\"message\"), \"Unexpected remove wishlist response\"\n\n            # 8. Confirm the tour is removed from wishlist\n            get_wishlist_after_removal_resp = session.get(f\"{BASE_URL}/api/wishlist\", timeout=TIMEOUT)\n            assert get_wishlist_after_removal_resp.status_code == 200, \\\n                f\"Get wishlist after removal failed: {get_wishlist_after_removal_resp.text}\"\n            wishlist_after_removal = get_wishlist_after_removal_resp.json()\n            assert all((item.get(\"tourId\") != tour_id and item.get(\"id\") != tour_id)\n                       for item in wishlist_after_removal), \"Tour still found in wishlist after removal\"\n\n            # 9. Check access control: attempt to get wishlist without authentication\n            session_no_auth = requests.Session()\n            no_auth_resp = session_no_auth.get(f\"{BASE_URL}/api/wishlist\", timeout=TIMEOUT)\n            assert no_auth_resp.status_code in (401, 403), \\\n                f\"Unauthorized wishlist access allowed: {no_auth_resp.text}\"\n\n            # 10. Check access control: attempt to add to wishlist without authentication\n            no_auth_add_resp = session_no_auth.post(\n                f\"{BASE_URL}/api/wishlist\",\n                json={\"tourId\": tour_id},\n                timeout=TIMEOUT,\n            )\n            assert no_auth_add_resp.status_code in (401, 403), \\\n                f\"Unauthorized add to wishlist allowed: {no_auth_add_resp.text}\"\n\n            # 11. Check access control: attempt to remove from wishlist without authentication\n            no_auth_remove_resp = session_no_auth.delete(\n                f\"{BASE_URL}/api/wishlist\",\n                json={\"tourId\": tour_id},\n                timeout=TIMEOUT,\n            )\n            assert no_auth_remove_resp.status_code in (401, 403), \\\n                f\"Unauthorized remove from wishlist allowed: {no_auth_remove_resp.text}\"\n\n        finally:\n            # Cleanup: delete the created tour (admin only)\n            del_url = f\"{BASE_URL}/api/admin/tours/{tour_id}\"\n            del_resp = session.delete(del_url, timeout=TIMEOUT)\n            if del_resp.status_code not in [200, 204, 404]:\n                raise AssertionError(f\"Failed to delete test tour: {del_resp.status_code} - {del_resp.text}\")\n\n    finally:\n        # Sign out the user to clean session ONLY if signed in\n        try:\n            sign_out_resp = session.post(f\"{BASE_URL}/api/auth/sign-out\", timeout=TIMEOUT)\n            assert sign_out_resp.status_code in (200, 204), f\"Sign out failed with status {sign_out_resp.status_code}\"\n        except Exception as e:\n            raise AssertionError(f\"Sign out failed: {str(e)}\")\n        finally:\n            session.close()\n\n\ntest_user_wishlist_functionality()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"<string>\", line 49, in test_user_wishlist_functionality\nAssertionError: Sign-up failed: 404 \n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"<string>\", line 157, in test_user_wishlist_functionality\nAssertionError: Sign out failed with status 400\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 164, in <module>\n  File \"<string>\", line 159, in test_user_wishlist_functionality\nAssertionError: Sign out failed: Sign out failed with status 400\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-09-19T16:21:34.636Z",
    "modified": "2025-09-19T16:23:57.222Z"
  },
  {
    "projectId": "2aee7dae-d28b-438a-954c-ee4fc4b1e1fd",
    "testId": "526e1e9b-e634-4459-b1b5-e978a0847796",
    "userId": "74a864c8-3021-7018-200a-5ce7885b869e",
    "title": "TC009-contactformsubmissionandinquirymanagement",
    "description": "Verify contact form submission with all required fields such as name, email, phone, subject, message, and inquiry type, and ensure data storage for follow-up.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:3000\"\nTIMEOUT = 30\n\ndef test_contact_form_submission_and_inquiry_management():\n    url = f\"{BASE_URL}/api/contact\"\n    headers = {\n        \"Content-Type\": \"application/json\"\n    }\n    payload = {\n        \"name\": \"John Doe\",\n        \"email\": \"john.doe@example.com\",\n        \"phone\": \"+1234567890\",\n        \"subject\": \"Inquiry about tour packages\",\n        \"message\": \"I would like to know more about the upcoming tours to Europe in winter.\",\n        \"inquiryType\": \"General\"\n    }\n\n    try:\n        response = requests.post(url, json=payload, headers=headers, timeout=TIMEOUT)\n        response.raise_for_status()\n    except requests.RequestException as e:\n        assert False, f\"Request failed: {e}\"\n\n    assert response.status_code == 201 or response.status_code == 200, f\"Unexpected status code: {response.status_code}\"\n    response_data = response.json()\n    # Assuming the API returns a JSON object with at least a success indication or the saved inquiry data\n    assert isinstance(response_data, dict), \"Response data is not a JSON object\"\n    # Check presence of keys that confirm data storage; adapt if actual keys differ\n    expected_keys = {\"id\", \"name\", \"email\", \"phone\", \"subject\", \"message\", \"inquiryType\", \"createdAt\"}\n    has_required_keys = expected_keys.intersection(response_data.keys())\n    assert has_required_keys, f\"Response JSON missing expected keys: {expected_keys}\"\n\ntest_contact_form_submission_and_inquiry_management()",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-09-19T16:21:34.641Z",
    "modified": "2025-09-19T16:22:52.947Z"
  },
  {
    "projectId": "2aee7dae-d28b-438a-954c-ee4fc4b1e1fd",
    "testId": "5b1710a3-9418-4895-8fd4-8cff1b6e9cbc",
    "userId": "74a864c8-3021-7018-200a-5ce7885b869e",
    "title": "TC010-publictestimonialdisplay",
    "description": "Test retrieval of public testimonials to ensure correct and accessible display of user feedback on the platform.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:3000\"\nTIMEOUT = 30\n\n\ndef test_public_testimonial_display():\n    url = f\"{BASE_URL}/api/testimonials\"\n    headers = {\n        \"Accept\": \"application/json\",\n        \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 \"\n                      \"(KHTML, like Gecko) Chrome/114.0.0.0 Safari/537.36\"\n    }\n\n    try:\n        response = requests.get(url, headers=headers, timeout=TIMEOUT)\n        response.raise_for_status()\n    except requests.RequestException as e:\n        assert False, f\"Request failed: {e}\"\n\n    # Validate response content-type header is JSON\n    content_type = response.headers.get(\"Content-Type\", \"\")\n    assert \"application/json\" in content_type, f\"Expected 'application/json' content-type, got '{content_type}'.\"\n\n    # Validate the response body content\n    try:\n        testimonials = response.json()\n    except ValueError:\n        assert False, \"Response is not valid JSON.\"\n\n    # The response should be a list (array) of testimonials\n    assert isinstance(testimonials, list), f\"Expected response to be a list but got {type(testimonials)}.\"\n\n    # If there are testimonials, validate at least one testimonial structure\n    if testimonials:\n        sample = testimonials[0]\n        assert isinstance(sample, dict), f\"Testimonial should be a dict, got {type(sample)}.\"\n        # Validate presence of common testimonial fields\n        # Because no schema details are given, check for usual plausible fields\n        possible_fields = [\"id\", \"name\", \"title\", \"comment\", \"rating\", \"date\"]\n        assert any(field in sample for field in possible_fields), \"Testimonial lacks expected fields.\"\n\n    # Additional accessibility check: ensure response is not empty (some testimonials should be public)\n    # It is valid that there are zero testimonials, but we note it\n    # So no failure for empty list, just pass\n\n\ntest_public_testimonial_display()",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-09-19T16:21:34.646Z",
    "modified": "2025-09-19T16:22:59.628Z"
  }
]
